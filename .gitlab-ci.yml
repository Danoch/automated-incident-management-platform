stages:
  - test
  - package
  - deploy_staging
  - deploy_canary  # üê¶ New stage for Canary Deployment
  - deploy_production
  - deploy_node_app # ‚úÖ Stage for EC2 Node.js app deployment
  - deploy_canary_ec2

variables:
  AWS_REGION: "us-east-1"
  AWS_ECR_REPO: "928568224370.dkr.ecr.us-east-1.amazonaws.com/node-app"
  EC2_HOST: "18.206.160.82"
  EC2_USER: "ec2-user"
  SSH_PRIVATE_KEY: $EC2_SSH_KEY  # ‚úÖ Add SSH key in GitLab CI/CD variables
  NODE_APP_DIR: "/home/ec2-user/node-app"
  LAMBDA_FUNCTION_NAME: "incident-response-lambda"
  DEPLOY_PACKAGE: "lambda_function.zip"
  PRODUCTION_LAMBDA_ALIAS: "production"

image: python:3.9

before_script:
  - pip install --upgrade pip awscli
  - pip install boto3

test:
  stage: test
  script:
    - pip install boto3 pytest
    - echo "Running tests..."
    - if [ -d "tests" ]; then pytest tests/; else echo "No tests found, skipping."; fi

package:
  stage: package
  script:
    - apt-get update && apt-get install -y zip
    - cd lambda_package
    - zip -r ../$DEPLOY_PACKAGE lambda_function.py
    - cd ..
  artifacts:
    paths:
      - $DEPLOY_PACKAGE

deploy_staging:
  stage: deploy_staging
  environment:
    name: staging
    url: "https://staging.example.com"
  script:
    - echo "Checking variables..."
    - echo "LAMBDA_FUNCTION_NAME is:" "$LAMBDA_FUNCTION_NAME"
    - echo "DEPLOY_PACKAGE is:" "$DEPLOY_PACKAGE"
    - echo "AWS_REGION is:" "$AWS_REGION"

    - |
      if [ -z "$LAMBDA_FUNCTION_NAME" ]; then 
        echo "‚ùå ERROR: LAMBDA_FUNCTION_NAME is empty!";
        exit 1;
      fi

    - echo "üöÄ Deploying to AWS Lambda..."
    - aws lambda update-function-code --function-name "$LAMBDA_FUNCTION_NAME" --zip-file fileb://"$DEPLOY_PACKAGE" --region "$AWS_REGION"

    - echo "‚úÖ Deployment finished!"
  only:
    - main

deploy_canary:
  stage: deploy_canary
  when: manual
  script:
    - echo "üöÄ Deploying Canary Release..."
    - |
      set -e  # üö® Detiene si hay errores
      LATEST_VERSION=$(aws lambda publish-version --function-name "$LAMBDA_FUNCTION_NAME" --query 'Version' --output text)
      echo "Latest Lambda Version: $LATEST_VERSION"
      
      JSON_CONFIG=$(printf '{"AdditionalVersionWeights": {"%s": 0.2}}' "$LATEST_VERSION")

      aws lambda update-alias --function-name "$LAMBDA_FUNCTION_NAME" --name "$PRODUCTION_LAMBDA_ALIAS" --routing-config "$JSON_CONFIG"

      echo "‚úÖ 20% of traffic directed to new version"
  only:
    - main


deploy_canary_ec2:
  stage: deploy_canary
  when: manual
  script:
    - echo "üöÄ Launching Canary EC2 instance..."
    - |
      set -e  # üö® Evita que siga si hay errores
      INSTANCE_ID=$(aws ec2 run-instances --image-id ami-032ae1bccc5be78ca --count 1 --instance-type t2.micro --key-name NewDanochKeyPair --security-groups my-security-group --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=canary-instance}]' --query 'Instances[0].InstanceId' --output text)
      echo "‚úÖ Canary Instance Deployed! Instance ID: $INSTANCE_ID"
      echo "INSTANCE_ID=$INSTANCE_ID" >> deploy.env
  artifacts:
    reports:
      dotenv: deploy.env  # save instance ID
  only:
    - main

deploy_production:
  stage: deploy_production
  when: manual
  script:
    - echo "üöÄ Deploying to Production..."
    - |
      set -e  # üö® Detener si hay errores
      LATEST_VERSION=$(aws lambda publish-version --function-name "$LAMBDA_FUNCTION_NAME" --query 'Version' --output text)
      
      echo "Latest Lambda Version: $LATEST_VERSION"
      
      if aws lambda get-alias --function-name "$LAMBDA_FUNCTION_NAME" --name "$PRODUCTION_LAMBDA_ALIAS" 2>/dev/null; then
        echo "Updating alias to new version..."
        aws lambda update-alias --function-name "$LAMBDA_FUNCTION_NAME" --name "$PRODUCTION_LAMBDA_ALIAS" --function-version "$LATEST_VERSION"
      else
        echo "Creating alias for first deployment..."
        aws lambda create-alias --function-name "$LAMBDA_FUNCTION_NAME" --name "$PRODUCTION_LAMBDA_ALIAS" --function-version "$LATEST_VERSION"
      fi
      
      echo "‚úÖ Production deployment complete!"

  after_script:
    - |
      if [ $? -ne 0 ]; then
        echo "‚ùå Deployment failed! Rolling back..."
        PREVIOUS_VERSION=$(aws lambda list-versions-by-function --function-name "$LAMBDA_FUNCTION_NAME" --query 'Versions[-2].Version' --output text || echo "NO_VERSION")
        if [ "$PREVIOUS_VERSION" != "NO_VERSION" ]; then
          echo "Rolling back to previous version: $PREVIOUS_VERSION"
          aws lambda update-alias --function-name "$LAMBDA_FUNCTION_NAME" --name "$PRODUCTION_LAMBDA_ALIAS" --function-version "$PREVIOUS_VERSION"
        else
          echo "‚ö† No previous version found, cannot roll back!"
        fi
      fi
  only:
    - main

deploy_node_app:
  stage: deploy_node_app
  image: docker:24.0
  services:
    - docker:dind
  variables:
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - apk add --no-cache bash openssh-client aws-cli
    - docker info
    - aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$AWS_ECR_REPO"
  script:
    - echo "üöÄ Building and deploying new version..."
    - docker build -t node-app .
    - docker tag node-app:latest "$AWS_ECR_REPO":latest
    - docker push "$AWS_ECR_REPO":latest
    - echo "‚úÖ Image pushed to ECR!"
    
    - echo "üöÄ Deploying on EC2..."
    - ssh "$EC2_USER@$EC2_HOST" << 'EOF'
        set -e
        aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin "$AWS_ECR_REPO"
        docker pull "$AWS_ECR_REPO":latest
        docker stop node-app-container || true
        docker rm node-app-container || true
        docker run -d -p 3000:3000 --name node-app-container "$AWS_ECR_REPO":latest
      EOF
  after_script:
    - |
      if [ $? -ne 0 ]; then
        echo "‚ùå Deployment failed! Rolling back..."
        PREVIOUS_TAG=$(aws ecr list-images --repository-name node-app --query 'imageIds[-2].imageTag' --output text || echo "NO_IMAGE")
        if [ "$PREVIOUS_TAG" != "NO_IMAGE" ]; then
          ssh "$EC2_USER@$EC2_HOST" << 'EOF'
            docker stop node-app-container || true
            docker rm node-app-container || true
            docker pull "$AWS_ECR_REPO:$PREVIOUS_TAG"
            docker run -d -p 3000:3000 --name node-app-container "$AWS_ECR_REPO:$PREVIOUS_TAG"
          EOF
        else
          echo "‚ö† No previous image found, cannot roll back!"
        fi
      fi
  only:
    - main



